Refactor the EPUB filename generation :
- in namegen.py, called from _process_single_epub_content in core.py. See also namegen_option in cli/options.py. See see namegen.md for some basic documention.
- currently, a namegen mini-language is used for generating filenames for EPUBs. The rules for EPUB Title, EPUB filename (on the filesystem) and EPUB directory (on the filesystem) are defined using a simple syntax with the rules passed as a parameter to the commands that generate an EPUB. If no option is passed, a DEFAULT_NAMEGEN_RULES is parsed and used. Keep all that. But in addition to that, I would like for the user to be able to pass to the same option (--namegen) the path to a .py file that will have the same functionality of generating the EPUB details. The .py file will have 3 def functions : to_title, to_filename, to_folder. Any of those is optional : if not present, the default procedure is used. That py will be loaded dynamically at runtime and be used to generate the EPUB details : the same "series, volumes, parts, fc" params will be passed to the functions like for the namegen mini-language.
- you can add a jncep/namegen_utils.py that contains utility functions that can be imported from a user namegen.py file using from jncep.namegen_utils import *. Reexport imported functions explicitly using __all__  if needed + define some if needed The goal is if the user creates a project with jncep as dependency, he can get autocomplete easily (for functions or types).
- in addition to a an explicit option passed by the user, if a file named namegen.py is found inside the config directory, it should be used as that role. 
- the py should be passed using absolute path if passed explicitly (in option or in config)
- add a config subcommand to generate such a py file. It should have one output option (file path or <folder path> namegen.py if the output is deemed a folder : the folder path should not be created only the file ; error otherwise ; do not overwrite a file : display an error if already exists ; add an option to overwrite plus a confirmation if found)  as to where the file will be generated. It should contain subs with function names pregenerated. If no output option is passed, it should be created in the config folder, name namegen.py. Make sure to output the path to the file after running that command.
- Add a section to namegen.md : explain the py interface used and how it is loaded and config tool to generate. Also, write a blurb that can be passed as a preface to a LLM by the user so it can explain in plain words what the output should be. Make sure that the blurb references all the cases of the EPUB generation (EPUB contains single part, multiple parts in a single volume, multiple parts in multiple volumes) so that the generated py always works. The blurb should reference to the LLM the data structures used as input as well. DO NOT add anything regarding the namegen mini-language to that blurb : it is about generating the py only.
- add a very small paragraph to README.md in ### Naming of the output EPUB explaining the .py EPUB file naming system and how to generate a basic version using the config subcommand
- refactor the default EPUB detail generation : currently parse t:legacy_t|n:_t>str_filesafe|f:legacy_f but should have similar functions as the .py interface with only series, volumes, parts, fc as params (create a legacy_n if needed) so they can be called from a user namegen.py if needed (make sure they are reeexported from namege_utils)
- refactor the parsing of the rules : make them parse only once. Currently parse function called at every EPUB file generation (namegen.parse_namegen_rule), although there is a global cache in namegen.py. I would like for that cache to be removed (unneeded) and the parsing to happen early, before any downloading has been performed (so an error can be displayed right away) and the procedure to name the EPUB be cached inside the options.namegen_rules (instead of the unparsed option like now). In the same vein, I would like the loading of the py file to happen early. The determination if the default procedure is used for some part should be determined there as well.
- Add debug logs for which version of namegen.py file is loaded, which function are found, which genereation used the default. Do not ouput as normal logs.
- make sure the test in test_namegen.py passes (uses the namegen mini-language) + add some test for loading a .py file similar to the namegen mini-language tests
